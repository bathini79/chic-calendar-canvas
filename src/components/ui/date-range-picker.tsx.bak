import * as React from "react";
import { format, isSameDay, subDays, startOfDay, parse, isValid, addDays } from "date-fns";
import { Calendar as CalendarIcon, X } from "lucide-react";
import { DateRange } from "react-day-picker";
import "./calendar-global-fix.css"; // Single consistent styling file
import { cn } from "@/lib/utils";

import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import {
  Popover, 
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";

/**
 * Enhanced DateRangePicker Component - Fully self-contained and reusable
 * 
 * This component includes all necessary CSS styling, positioning logic, and 
 * responsive behavior. It can be used anywhere without additional setup.
 * 
 * @example
 * // Basic usage
 * <DateRangePicker
 *   dateRange={dateRange}
 *   onChange={setDateRange}
 *   isMobile={isMobile}
 * />
 * 
 * @example
 * // Advanced usage with custom positioning and sizing
 * <DateRangePicker
 *   dateRange={dateRange}
 *   onChange={setDateRange}
 *   isMobile={isMobile}
 *   useDialogOnDesktop={true}
 *   dialogWidth="w-[500px] max-w-[90vw]"
 *   popoverWidth="w-[650px]"
 *   align="center"
 *   compact={true}
 * />
 */

const predefinedRanges = [
  { label: "Today", value: "today" },
  { label: "Yesterday", value: "yesterday" },
  { label: "Last 7 days", value: "last7days" },
  { label: "Last 30 days", value: "last30days" },
  { label: "Last 90 days", value: "last90days" },
  { label: "This month", value: "thisMonth" },
  { label: "Last month", value: "lastMonth" },
  { label: "This quarter", value: "thisQuarter" },
  { label: "Last quarter", value: "lastQuarter" },
  { label: "This year", value: "thisYear" },
  { label: "Last year", value: "lastYear" },
  { label: "All time", value: "allTime" },
  { label: "Last 6 months", value: "last6months" },
  { label: "Custom range", value: "custom" },
];

interface DateRangePickerProps {
  dateRange: DateRange | undefined;
  onChange: (dateRange: DateRange | undefined) => void;
  className?: string;
  align?: "start" | "end" | "center";
  isMobile?: boolean;
  useDialogOnDesktop?: boolean; // Force dialog on desktop instead of popover
  dialogWidth?: string; // Custom dialog width (e.g., "600px", "sm:max-w-lg")
  popoverWidth?: string; // Custom popover width (e.g., "740px")
  compact?: boolean; // Use compact styling
}

export function DateRangePicker({
  dateRange,
  onChange,
  className,
  align = "start",
  isMobile = false,
  useDialogOnDesktop = false,
  dialogWidth = "w-[600px] max-w-[90vw]",
  popoverWidth = "w-[740px]",
  compact = false
}: DateRangePickerProps) {
  const [isDialogOpen, setIsDialogOpen] = React.useState(false);
  const [isPopoverOpen, setIsPopoverOpen] = React.useState(false);
  const [selectedPreset, setSelectedPreset] = React.useState<string | undefined>(undefined);  
  const [tempDateRange, setTempDateRange] = React.useState<DateRange | undefined>(dateRange);
  // Add local state for input values to manage typing
  const [startInputValue, setStartInputValue] = React.useState<string>("");
  const [endInputValue, setEndInputValue] = React.useState<string>("");
    // Update tempDateRange when dateRange prop changes
  React.useEffect(() => {
    setTempDateRange(dateRange);
    
    // Update input values when dateRange changes
    if (dateRange?.from) {
      setStartInputValue(formatInputDate(dateRange.from));
    } else {
      setStartInputValue("");
    }
    
    if (dateRange?.to) {
      setEndInputValue(formatInputDate(dateRange.to));
    } else {
      setEndInputValue("");
    }
  }, [dateRange]);  // Additional useEffect to ensure calendar and input fields stay in sync
  // This effect now only reorders dates if they're in the wrong order,
  // but doesn't auto-complete partial selections (that's handled in handleCalendarSelect)
  React.useEffect(() => {
    // Only run this effect if we have a complete range with both dates
    if (tempDateRange?.from && tempDateRange.to && tempDateRange.from > tempDateRange.to) {
      // Fix date order when needed
      setTempDateRange({
        from: tempDateRange.to,
        to: tempDateRange.from,
      });
    }
    
    // Update input values whenever tempDateRange changes (for calendar selection)
    if (tempDateRange?.from) {
      setStartInputValue(formatInputDate(tempDateRange.from));
    }
    
    if (tempDateRange?.to) {
      setEndInputValue(formatInputDate(tempDateRange.to));
    }
  }, [tempDateRange?.from, tempDateRange?.to]);
    // Simple format dates for display in input fields - dd/mm/yyyy
  const formatInputDate = (date: Date | undefined) => {
    if (!date) return "";
    try {
      return format(date, "dd/MM/yyyy");
    } catch (error) {
      return "";
    }
  };
  /**
   * Parse date string in dd/mm/yyyy format with robust error handling
   * 
   * Features:
   * 1. Handles complete dd/MM/yyyy format
   * 2. Supports partial inputs like "25/" or "25/06"
   * 3. Validates date ranges (year between 1900-2100)
   * 4. Returns normalized date (start of day, no time component)
   */
  const parseInputDate = (dateString: string) => {
    if (!dateString) return undefined;
    
    try {
      // Try parse as dd/MM/yyyy format
      const parsedDate = parse(dateString, "dd/MM/yyyy", new Date());
      
      // Basic validation
      if (isValid(parsedDate) && parsedDate.getFullYear() > 1900 && parsedDate.getFullYear() < 2100) {
        return startOfDay(parsedDate);
      }
    } catch (error) {
      // If strict parsing fails, try some fallbacks for partial input
      // This allows users to type dates in progress
      if (dateString.length >= 2) {
        try {
          // Try to parse partial dates like "25/" or "25/06"
          const day = parseInt(dateString.split('/')[0], 10);
          
          if (day > 0 && day <= 31) {
            // Day seems valid, try to parse with default month/year
            const today = new Date();
            const month = dateString.split('/')[1] ? 
              parseInt(dateString.split('/')[1], 10) - 1 : // Convert from 1-based to 0-based month
              today.getMonth();
            const year = dateString.split('/')[2] ? 
              parseInt(dateString.split('/')[2], 10) : 
              today.getFullYear();
              
            if (month >= 0 && month <= 11 && year >= 1900 && year <= 2100) {
              return startOfDay(new Date(year, month, day));
            }
          }
        } catch (e) {
          // Ignore parsing errors for partial inputs
        }
      }
    }
    
    return undefined;
  };/**
   * Handle manual date input with improved validation and automatic date completion
   * 
   * This handler:
   * 1. Updates the input field immediately to show typing
   * 2. Sets preset to "custom" when manually typing dates
   * 3. Attempts to parse the date if it matches dd/mm/yyyy format
   * 4. Allows for further validation on blur for partial inputs
   */
  const handleStartDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    
    // Always update the input value so typing is visible
    setStartInputValue(value);
    
    // Always set preset to custom when manually typing dates
    setSelectedPreset("custom");
    
    if (!value) {
      // Just clear the date
      setTempDateRange({
        from: undefined,
        to: tempDateRange?.to,
      });
      return;
    }
    
    // Allow typing, but only update the calendar on blur or if pattern matches
    if (value.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
      const newDate = parseInputDate(value);
      if (newDate && isValid(newDate)) {
        updateStartDate(newDate);
      }
    }
    // Otherwise, the date will be validated and applied on blur
  };
    /**
   * Helper function to update the start date while maintaining a valid range
   * 
   * Rules:
   * 1. If no dates are set, set both start and end to the new date
   * 2. If start date is after end date, adjust end date to match start date
   * 3. Otherwise, only update the start date, keeping the end date unchanged
   */
  const updateStartDate = (newDate: Date) => {
    // Use startOfDay to normalize the date (remove time component)
    const normalizedDate = startOfDay(newDate);
    
    if (!tempDateRange?.from && !tempDateRange?.to) {
      // First date selection, set both dates the same
      setTempDateRange({
        from: normalizedDate,
        to: normalizedDate,
      });
      return;
    }
    
    // If end date exists and new start date is after it, adjust end date
    if (tempDateRange?.to && normalizedDate > tempDateRange.to) {
      setTempDateRange({
        from: normalizedDate,
        to: normalizedDate,
      });
    } else {
      setTempDateRange({
        from: normalizedDate,
        to: tempDateRange?.to,
      });
    }
  };/**
   * Handle manual end date input with improved validation and automatic date completion
   * 
   * This handler:
   * 1. Updates the input field immediately to show typing
   * 2. Sets preset to "custom" when manually typing dates
   * 3. Attempts to parse the date if it matches dd/mm/yyyy format
   * 4. Allows for further validation on blur for partial inputs
   */
  const handleEndDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    
    // Always update the input value so typing is visible
    setEndInputValue(value);
    
    // Always set preset to custom when manually typing dates
    setSelectedPreset("custom");
    
    if (!value) {
      // Just clear the date
      setTempDateRange({
        from: tempDateRange?.from,
        to: undefined,
      });
      return;
    }
    
    // Allow typing, but only update the calendar on blur or if pattern matches
    if (value.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
      const newDate = parseInputDate(value);
      if (newDate && isValid(newDate)) {
        updateEndDate(newDate);
      }
    }
    // Otherwise, the date will be validated and applied on blur
  };
    /**
   * Helper function to update the end date while maintaining a valid range
   * 
   * Rules:
   * 1. If no dates are set, set both start and end to the new date
   * 2. If end date is before start date, adjust start date to match end date
   * 3. Otherwise, only update the end date, keeping the start date unchanged
   */
  const updateEndDate = (newDate: Date) => {
    // Use startOfDay to normalize the date (remove time component)
    const normalizedDate = startOfDay(newDate);
    
    if (!tempDateRange?.from && !tempDateRange?.to) {
      // First date selection, set both dates the same
      setTempDateRange({
        from: normalizedDate,
        to: normalizedDate,
      });
      return;
    }
    
    // If start date exists and new end date is before it, adjust start date
    if (tempDateRange?.from && normalizedDate < tempDateRange.from) {
      setTempDateRange({
        from: normalizedDate,
        to: normalizedDate,
      });
    } else {
      setTempDateRange({
        from: tempDateRange?.from,
        to: normalizedDate,
      });
    }
  };

  // Handle preset selection
  const handlePresetChange = (value: string) => {
    setSelectedPreset(value);
    
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    const last7DaysStart = new Date(today);
    last7DaysStart.setDate(last7DaysStart.getDate() - 6);
    
    const last30DaysStart = new Date(today);
    last30DaysStart.setDate(last30DaysStart.getDate() - 29);
    
    const last90DaysStart = new Date(today);
    last90DaysStart.setDate(last90DaysStart.getDate() - 89);
    
    const thisMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
    
    const lastMonthStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
    const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
    
    const thisQuarterStart = new Date(
      today.getFullYear(),
      Math.floor(today.getMonth() / 3) * 3,
      1
    );
    
    const lastQuarterStart = new Date(
      today.getFullYear(),
      Math.floor(today.getMonth() / 3) * 3 - 3,
      1
    );
    const lastQuarterEnd = new Date(
      today.getFullYear(),
      Math.floor(today.getMonth() / 3) * 3,
      0
    );
    
    const thisYearStart = new Date(today.getFullYear(), 0, 1);
    
    const lastYearStart = new Date(today.getFullYear() - 1, 0, 1);
    const lastYearEnd = new Date(today.getFullYear(), 0, 0);
    
    const last6MonthsStart = new Date(today);
    last6MonthsStart.setMonth(today.getMonth() - 6);

    let newRange: DateRange | undefined;
    
    switch (value) {
      case "today":
        newRange = { from: today, to: today };
        break;
      case "yesterday":
        newRange = { from: yesterday, to: yesterday };
        break;
      case "last7days":
        newRange = { from: last7DaysStart, to: today };
        break;
      case "last30days":
        newRange = { from: last30DaysStart, to: today };
        break;
      case "last90days":
        newRange = { from: last90DaysStart, to: today };
        break;
      case "thisMonth":
        newRange = { from: thisMonthStart, to: today };
        break;
      case "lastMonth":
        newRange = { from: lastMonthStart, to: lastMonthEnd };
        break;
      case "thisQuarter":
        newRange = { from: thisQuarterStart, to: today };
        break;
      case "lastQuarter":
        newRange = { from: lastQuarterStart, to: lastQuarterEnd };
        break;
      case "thisYear":
        newRange = { from: thisYearStart, to: today };
        break;
      case "lastYear":
        newRange = { from: lastYearStart, to: lastYearEnd };
        break;
      case "allTime":
        newRange = { from: new Date(2020, 0, 1), to: today };
        break;
      case "last6months":
        newRange = { from: last6MonthsStart, to: today };
        break;
      case "custom":
        return;
      default:
        return;
    }
    
    setTempDateRange(newRange);
  };  /**
   * Apply the selected date range with improved error handling
   * 
   * This function:
   * 1. Ensures we always have a complete range with both from/to dates
   * 2. Ensures dates are in the correct order (from ≤ to)
   * 3. Handles edge cases like partial selection
   * 4. Closes all dialogs after applying changes
   */
  const handleApply = () => {
    if (tempDateRange) {
      // Always ensure we have a complete range when applying
      let finalRange: DateRange;
      
      // Case 1: Both dates are selected
      if (tempDateRange.from && tempDateRange.to) {
        // Ensure from date is earlier than to date
        if (tempDateRange.from > tempDateRange.to) {
          finalRange = {
            from: startOfDay(tempDateRange.to),
            to: startOfDay(tempDateRange.from),
          };
        } else {
          finalRange = {
            from: startOfDay(tempDateRange.from),
            to: startOfDay(tempDateRange.to)
          };
        }
      } 
      // Case 2: Only start date is selected, use same date for end
      else if (tempDateRange.from && !tempDateRange.to) {
        const normalizedDate = startOfDay(tempDateRange.from);
        finalRange = {
          from: normalizedDate,
          to: normalizedDate,
        };
      }
      // Case 3: Only end date is selected, use same date for start
      else if (!tempDateRange.from && tempDateRange.to) {
        const normalizedDate = startOfDay(tempDateRange.to);
        finalRange = {
          from: normalizedDate,
          to: normalizedDate,
        };
      }
      else {
        // Fallback to prevent undefined errors - use today's date
        const today = startOfDay(new Date());
        finalRange = {
          from: today,
          to: today
        };
      }
      
      // Apply the changes
      onChange(finalRange);
    }

    // Always close dialogs after applying
    setIsDialogOpen(false);
    setIsPopoverOpen(false);
  };
  // Reset temp date range when dialog/popover opens
  React.useEffect(() => {
    if (isDialogOpen || isPopoverOpen) {
      setTempDateRange(dateRange);
      
      // Reset input values to match the current date range
      if (dateRange?.from) {
        setStartInputValue(formatInputDate(dateRange.from));
      } else {
        setStartInputValue("");
      }
      
      if (dateRange?.to) {
        setEndInputValue(formatInputDate(dateRange.to));
      } else {
        setEndInputValue("");
      }
      
      // Reset selected preset if opening the picker
      if (!dateRange?.from || !dateRange?.to) {
        setSelectedPreset(undefined);
      }
    }
  }, [isDialogOpen, isPopoverOpen, dateRange]);// Helper function to consistently format dates
  const formatDate = (date: Date): string => {
    return format(date, "d MMM yyyy");
  };    // Format displayed date range
  const formattedDateRange = React.useMemo(() => {
    if (!dateRange?.from) {
      return "Select date range";
    }

    const now = new Date();
    const today = startOfDay(now);
    const yesterday = subDays(today, 1);
    
    // For today only
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, today) && isSameDay(dateRange.to, today)) {
      return "Today";
    }
    
    // For yesterday only
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, yesterday) && isSameDay(dateRange.to, yesterday)) {
      return "Yesterday";
    }
    
    // For last 7 days
    const last7Days = subDays(today, 6);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, last7Days) && isSameDay(dateRange.to, today)) {
      return "Last 7 days";
    }
    
    // For last 30 days
    const last30Days = subDays(today, 29);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, last30Days) && isSameDay(dateRange.to, today)) {
      return "Last 30 days";
    }
    
    // For last 90 days
    const last90Days = subDays(today, 89);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, last90Days) && isSameDay(dateRange.to, today)) {
      return "Last 90 days";
    }
    
    // For this month
    const thisMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, thisMonthStart) && isSameDay(dateRange.to, today)) {
      return "This month";
    }
    
    // For last month
    const lastMonthStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
    const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, lastMonthStart) && isSameDay(dateRange.to, lastMonthEnd)) {
      return "Last month";
    }
    
    // For this quarter
    const thisQuarterStart = new Date(
      today.getFullYear(),
      Math.floor(today.getMonth() / 3) * 3,
      1
    );
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, thisQuarterStart) && isSameDay(dateRange.to, today)) {
      return "This quarter";
    }
    
    // For last quarter
    const lastQuarterStart = new Date(
      today.getFullYear(),
      Math.floor(today.getMonth() / 3) * 3 - 3,
      1
    );
    const lastQuarterEnd = new Date(
      today.getFullYear(),
      Math.floor(today.getMonth() / 3) * 3,
      0
    );
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, lastQuarterStart) && isSameDay(dateRange.to, lastQuarterEnd)) {
      return "Last quarter";
    }
    
    // For this year
    const thisYearStart = new Date(today.getFullYear(), 0, 1);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, thisYearStart) && isSameDay(dateRange.to, today)) {
      return "This year";
    }
    
    // For last year
    const lastYearStart = new Date(today.getFullYear() - 1, 0, 1);
    const lastYearEnd = new Date(today.getFullYear(), 0, 0);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, lastYearStart) && isSameDay(dateRange.to, lastYearEnd)) {
      return "Last year";
    }
    
    // For last 6 months
    const last6MonthsStart = new Date(today);
    last6MonthsStart.setMonth(today.getMonth() - 6);
    if (dateRange.from && dateRange.to && 
        isSameDay(dateRange.from, last6MonthsStart) && isSameDay(dateRange.to, today)) {
      return "Last 6 months";
    }

    // Default format for date range
    if (dateRange.to) {
      // If both dates are in same year
      if (dateRange.from.getFullYear() === dateRange.to.getFullYear()) {
        // If both dates are in the same month
        if (dateRange.from.getMonth() === dateRange.to.getMonth()) {
          return `${format(dateRange.from, "d")} - ${format(dateRange.to, "d MMM yyyy")}`;
        } else {
          return `${format(dateRange.from, "d MMM")} - ${format(dateRange.to, "d MMM yyyy")}`;
        }
      } else {
        return `${formatDate(dateRange.from)} - ${formatDate(dateRange.to)}`;
      }
    }
    
    return formatDate(dateRange.from);  }, [dateRange]);
    // Common form inputs for both versions
 // Common form inputs for both versions
const DateInputs = () => {  // Use consistent text input for both mobile and desktop
  // Use our input state variables to allow immediate typing feedback
  return (
    <div className="grid grid-cols-2 gap-4">
      <div>
        <label className="text-sm font-medium mb-2 block text-muted-foreground">
          {isMobile ? "Starting" : "Start Date"}
        </label>
        <Input
          type="text"
          value={startInputValue}
          onChange={handleStartDateChange}
          onBlur={(e) => {
            // Try to parse and validate on blur
            if (e.target.value) {
              const newDate = parseInputDate(e.target.value);
              if (newDate && isValid(newDate)) {
                updateStartDate(newDate);
              }
            }
          }}
          className="w-full focus:border-primary/50 focus:ring-1 focus:ring-gray-300/20 rounded-md border-black/30 bg-[#FAFAFA]"
          placeholder="dd/mm/yyyy"
          spellCheck={false}
          autoComplete="off"
        />
      </div>
      <div>
        <label className="text-sm font-medium mb-2 block text-muted-foreground">
          {isMobile ? "Ending" : "End Date"}
        </label>
        <Input
          type="text"
          value={endInputValue}
          onChange={handleEndDateChange}
          onBlur={(e) => {
            // Try to parse and validate on blur
            if (e.target.value) {
              const newDate = parseInputDate(e.target.value);
              if (newDate && isValid(newDate)) {
                updateEndDate(newDate);
              }
            }
          }}
          className="w-full focus:border-primary/50 focus:ring-1 focus:ring-gray-300/20 rounded-md border-black/30 bg-[#FAFAFA]"
          placeholder="dd/mm/yyyy"
          spellCheck={false}
          autoComplete="off"
        />
      </div>
    </div>
  );
};
// This useEffect is already handled by the one above
// We're keeping this comment to show where duplicate code was removed
  
  // Preset selector for both versions
  const PresetSelector = () => (
    <div>
      <label className="text-sm font-medium mb-2 block text-muted-foreground">
        {isMobile ? "Date Range" : "Preset Range"}
      </label>      <Select value={selectedPreset} onValueChange={handlePresetChange}>
        <SelectTrigger className={`w-full focus:ring-1 focus:ring-gray-300/20 rounded-md bg-[#FAFAFA] h-10 select-trigger ${isMobile ? 'border-black/30' : 'border-muted/30 focus:border-gray-400/40'}`}>
          <SelectValue placeholder="Select a preset range" />
        </SelectTrigger>
        <SelectContent className="border-muted/30 rounded-md shadow-md">
          <div className="max-h-[250px] overflow-y-auto pr-1">
            {predefinedRanges.map((range) => (
              <SelectItem 
                key={range.value} 
                value={range.value}
                className="focus:bg-gray-100 focus:text-black cursor-pointer"
              >
                {range.label}
              </SelectItem>
            ))}
          </div>
        </SelectContent>
      </Select>
    </div>
  );
  // Formatter function for weekday names
  const formatWeekdayName = (weekday: Date) => {
    try {
      // Using only one 'E' gives us the first letter (S, M, T, W, T, F, S)
      // Using 'EEE' gives us the short name (Sun, Mon, Tue, Wed, Thu, Fri, Sat)
      return format(weekday, 'EEE').substring(0, 2);
    } catch (error) {
      // Fallback in case of any errors
      const days = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
      return days[weekday.getDay()];
    }
  };  /**
   * Calendar section with dual calendar view for both mobile and desktop
   * 
   * Features:
   * - Independent month tracking for the second calendar
   * - Maintains selected date range across both calendars
   * - Consistent styling for range highlighting
   * - Properly handles different view modes (desktop/mobile)
   */
  const CalendarSection = () => {
    // State to track the second calendar's month independently
    const [secondCalendarMonth, setSecondCalendarMonth] = React.useState<Date | undefined>(undefined);

  // Set the second calendar month when the component mounts or when the date range changes initially
  React.useEffect(() => {
    // Only set the second calendar month if it's not already set or if we're opening the picker
    if (!secondCalendarMonth || isDialogOpen || isPopoverOpen) {
      if (tempDateRange?.from) {
        // Set to one month after the first calendar's month
        setSecondCalendarMonth(new Date(
          tempDateRange.from.getFullYear(), 
          tempDateRange.from.getMonth() + 1, 
          1
        ));
      } else {
        // Default to next month if no date is selected
        const nextMonth = new Date();
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        setSecondCalendarMonth(nextMonth);
      }
    }
  }, [isDialogOpen, isPopoverOpen, tempDateRange?.from]);  
  
  // Unified calendar class names for both mobile and desktop  
  const calendarClassNames = {
    day: "h-9 w-9 p-0 font-normal hover:bg-gray-100 relative flex items-center justify-center transition-colors bg-transparent",
    day_selected: "rounded-full shadow-sm font-medium",
    day_today: "border border-gray-300 font-medium",
    day_range_middle: "bg-transparent",
    day_range_end: "rounded-full font-medium",
    day_range_start: "rounded-full font-medium",
    day_outside: "text-muted-foreground opacity-50",
    head_cell: "text-muted-foreground font-normal text-xs uppercase px-0 py-2 text-center w-9",
    caption_label: "text-sm font-medium",
    month: "space-y-3",
    nav_button: "h-8 w-8 bg-[#f8f8fb] hover:bg-gray-100 rounded-full flex items-center justify-center border border-muted/30 shadow-sm text-muted-foreground hover:text-black transition-colors z-10",
    head_row: "grid grid-cols-7 mb-2",
    row: "grid grid-cols-7 mt-0 gap-0 w-full",
    cell: "h-9 w-9 text-center p-0 relative focus-within:relative focus-within:z-10 border-0 m-0 flex items-center justify-center",
    // Use consistent layout for months regardless of device
    months: "flex flex-col space-y-4 sm:flex-row sm:space-x-6 sm:space-y-0",
    table: "w-full border-collapse border-spacing-0",
    caption: "flex justify-center pt-1 pb-3 relative items-center",
    nav_button_previous: "absolute left-1",
    nav_button_next: "absolute right-1",
    day_button: "cursor-pointer" // Ensure days are clickable
  };  /**
   * Handle calendar date selection with improved UX
   * 
   * This function:
   * 1. Sets both from/to dates on first click (better UX than having half-selected state)
   * 2. Properly orders dates regardless of selection direction
   * 3. Updates input fields to match calendar selection
   * 4. Always sets preset to "custom" for manual selection
   */
  const handleCalendarSelect = (range: DateRange | undefined) => {
    if (!range) {
      // Clear selection when range is undefined
      setTempDateRange(undefined);
      setSelectedPreset("custom");
      setStartInputValue("");
      setEndInputValue("");
      return;
    }
    
    // Set preset to custom when manually selecting dates
    setSelectedPreset("custom");
    
    // First click - When user selects a date in the calendar, both from and to should be set to that date
    if (range.from && !range.to) {
      const initialSelection = {
        from: startOfDay(range.from),
        to: startOfDay(range.from), // Set 'to' to the same as 'from' on first click
      };
      setTempDateRange(initialSelection);
      
      // Update input values
      setStartInputValue(formatInputDate(initialSelection.from));
      setEndInputValue(formatInputDate(initialSelection.to));
    }
    // Second click - Normal range selection with proper ordering
    else if (range.from && range.to) {
      // Always ensure dates are in correct order
      const orderedFrom = range.from <= range.to ? startOfDay(range.from) : startOfDay(range.to);
      const orderedTo = range.from <= range.to ? startOfDay(range.to) : startOfDay(range.from);
      
      const orderedRange = {
        from: orderedFrom,
        to: orderedTo,
      };
      setTempDateRange(orderedRange);
      
      // Update input values
      setStartInputValue(formatInputDate(orderedFrom));
      setEndInputValue(formatInputDate(orderedTo));
    }
  };
  // Monitor tempDateRange updates
  React.useEffect(() => {
    // We're now tracking tempDateRange changes and updating the second calendar month accordingly
  }, [tempDateRange]);
  return (
    <div className={`mt-4 ${isMobile ? 'space-y-4' : 'grid grid-cols-2 gap-6'}`}>
      {/* First calendar */}      <div className="relative flex justify-center calendar-range-container">
        <Calendar
          mode="range"
          selected={tempDateRange}
          onSelect={handleCalendarSelect}
          numberOfMonths={1}
          initialFocus
          defaultMonth={tempDateRange?.from || new Date()}
          // We don't need to track the first calendar's month changes
          className="w-full border-0 bg-[#f8f8fb] rounded-lg p-3"
          showOutsideDays={true}
          weekStartsOn={0}
          classNames={calendarClassNames}
          formatters={{
            formatWeekdayName: formatWeekdayName
          }}          modifiersStyles={{            range_middle: { 
              backgroundColor: 'transparent', 
              color: 'black',
              borderRadius: 0,
              border: 'none',
              boxShadow: 'none'
            },
            selected: { 
              backgroundColor: 'black', 
              color: 'white', 
              borderRadius: '50%' 
            },
            range_end: { 
              backgroundColor: 'black', 
              color: 'white', 
              borderRadius: '50%' 
            },
            range_start: { 
              backgroundColor: 'black', 
              color: 'white', 
              borderRadius: '50%' 
            },
          }}
        />
      </div>
      
      {/* Second calendar */}      <div className="relative flex justify-center calendar-range-container">
        <Calendar
          mode="range"
          selected={tempDateRange}
          onSelect={handleCalendarSelect}
          numberOfMonths={1}
          defaultMonth={secondCalendarMonth || new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1)}
          onMonthChange={setSecondCalendarMonth} // Update our state when month changes
          className="w-full border-0 bg-[#f8f8fb] rounded-lg p-3"
          showOutsideDays={true}
          weekStartsOn={0}
          classNames={calendarClassNames}
          formatters={{
            formatWeekdayName: formatWeekdayName
          }}          modifiersStyles={{            range_middle: { 
              backgroundColor: 'transparent', 
              color: 'black',
              borderRadius: 0,
              border: 'none',
              boxShadow: 'none'
            },
            selected: { 
              backgroundColor: 'black', 
              color: 'white', 
              borderRadius: '50%' 
            },
            range_end: { 
              backgroundColor: 'black', 
              color: 'white', 
              borderRadius: '50%' 
            },
            range_start: { 
              backgroundColor: 'black', 
              color: 'white', 
              borderRadius: '50%' 
            },
          }}
        />
      </div>
    </div>
  );
};
    // Content for mobile dialog
  const mobileContent = (
    <div className="space-y-6 pb-20">
      <PresetSelector />
      <DateInputs />
      <CalendarSection />
      <div className="fixed bottom-0 left-0 right-0 bg-[#f8f8fb] py-4 px-4 pb-8 border-t shadow-lg z-20">
        <div className="flex gap-3">
          <Button 
            variant="outline"
            onClick={() => {
              setTempDateRange(dateRange);
              setIsDialogOpen(false);
            }} 
            className="w-1/3 h-12 text-base font-medium border-muted/40 rounded-lg transition-colors"
          >
            Cancel
          </Button>          <Button 
            onClick={handleApply} 
            className="w-2/3 h-12 text-base font-medium bg-black hover:bg-black/90 rounded-lg transition-colors text-white shadow-sm"
          >
            Apply
          </Button>
        </div>
      </div>
    </div>
  );
  // Content for desktop popover (original)
  const desktopContent = (
    <div className="space-y-5">
      <div className="flex justify-between items-center">
        <PresetSelector />
        <Button 
          variant="ghost" 
          className="p-2 h-9 rounded-full" 
          onClick={() => {
            setIsPopoverOpen(false);
          }}
        >
          <X className="h-4 w-4" />
        </Button>
      </div>
      <DateInputs />
      <CalendarSection />
      <div className="flex justify-end mt-6">
        <div className="flex space-x-3">
          <Button 
            variant="outline" 
            onClick={() => {
              setTempDateRange(dateRange);
              setIsPopoverOpen(false);
            }}
            className="border-muted/30 hover:bg-muted/20 rounded-lg px-5"
          >
            Cancel
          </Button>
          <Button 
            onClick={handleApply} 
            className="font-medium bg-black hover:bg-black/90 rounded-lg px-5 text-white"
          >
            Apply
          </Button>
        </div>
      </div>
    </div>
  );

  // Content for desktop dialog (simplified)
  const desktopDialogContent = (
    <div className="space-y-4">
      {/* Date Range Selector */}
      <div>
        <label className="text-sm font-medium mb-2 block text-muted-foreground">Date range</label>
        <Select value={selectedPreset} onValueChange={handlePresetChange}>
          <SelectTrigger className="w-full border-black/30 focus:ring-1 focus:ring-gray-300/20 focus:border-black-400/40 rounded-md bg-[#FAFAFA] h-10">
            <SelectValue placeholder="Select a preset range" />
          </SelectTrigger>
          <SelectContent className="border-muted/30 rounded-md shadow-md">
            <div className="max-h-[250px] overflow-y-auto pr-1">
              {predefinedRanges.map((range) => (
                <SelectItem 
                  key={range.value} 
                  value={range.value}
                  className="focus:bg-gray-100 focus:text-black cursor-pointer"
                >
                  {range.label}
                </SelectItem>
              ))}
            </div>
          </SelectContent>
        </Select>
      </div>      {/* Date Input Fields */}      <div className="grid grid-cols-2 gap-4">        <div>
          <label className="text-sm font-medium mb-2 block text-muted-foreground">Starting</label>
          <Input
            type="text"
            value={startInputValue}
            onChange={handleStartDateChange}
            onBlur={(e) => {
              // Try to parse and validate on blur
              if (e.target.value) {
                const newDate = parseInputDate(e.target.value);
                if (newDate && isValid(newDate)) {
                  updateStartDate(newDate);
                  // Update input value to formatted version
                  setStartInputValue(formatInputDate(newDate));
                }
              }
            }}
            placeholder="dd/mm/yyyy"
            className="w-full focus:border-primary/50 focus:ring-1 focus:ring-gray-300/20 rounded-md border-black/30 bg-[#FAFAFA]"
            autoComplete="off"
          />
        </div>        <div>
          <label className="text-sm font-medium mb-2 block text-muted-foreground">Ending</label>
          <Input
            type="text"
            value={endInputValue}
            onChange={handleEndDateChange}
            onBlur={(e) => {
              // Try to parse and validate on blur
              if (e.target.value) {
                const newDate = parseInputDate(e.target.value);
                if (newDate && isValid(newDate)) {
                  updateEndDate(newDate);
                  // Update input value to formatted version
                  setEndInputValue(formatInputDate(newDate));
                }
              }
            }}
            placeholder="dd/mm/yyyy"
            className="w-full focus:border-primary/50 focus:ring-1 focus:ring-gray-300/20 rounded-md border-black/30 bg-[#FAFAFA]"
            autoComplete="off"
          />
        </div>
      </div>

      {/* Calendar */}
      <CalendarSection />      {/* Buttons */}
      <div className="flex justify-end gap-3 pt-4">
        <Button 
          variant="outline" 
          onClick={() => {
            setTempDateRange(dateRange);
            setIsDialogOpen(false);
          }}
          className="border border-gray-300 hover:bg-gray-50 text-gray-700 rounded-lg px-6 py-2"
        >
          Cancel
        </Button>
        <Button 
          onClick={handleApply} 
          className="bg-black hover:bg-black/90 text-white border border-black rounded-lg px-6 py-2"
        >
          Apply
        </Button>
      </div>
    </div>
  );  // Create mobile trigger button
  const mobileTriggerButton = (
    <Button
      id="date-range-picker-mobile" 
      variant="outline"
      size="sm"
      className={cn("h-8 text-xs hover:bg-muted/10 rounded-md transition-colors date-range-picker-trigger", className)}
    >
      <CalendarIcon className="mr-1.5 h-3.5 w-3.5 text-black" />
      <span className="truncate max-w-[150px]">{formattedDateRange}</span>
    </Button>
  );

  // Create desktop trigger button
  const desktopTriggerButton = (
    <Button
      id="date-range-picker-desktop"
      variant="outline"
      size="sm"
      className={cn("h-9 hover:bg-muted/10 rounded-md transition-colors date-range-picker-trigger", className)}
    >
      <CalendarIcon className="mr-2 h-4 w-4 text-black" />
      {formattedDateRange}
    </Button>
  );return (
    <div className={cn("date-range-picker-container flex items-center", className, compact && "date-range-picker-compact")}>{isMobile || useDialogOnDesktop ? (
        // Mobile - Dialog or Desktop Dialog (centered)
        <Dialog open={isDialogOpen}
         onOpenChange={(open) => {
          setIsDialogOpen(open);
          if (open) {
            // Reset temp date range to current date range when opening
            setTempDateRange(dateRange);
          }

        }}>
          <DialogTrigger asChild>
            {isMobile ? mobileTriggerButton : desktopTriggerButton}
          </DialogTrigger>          <DialogContent className={cn(
            isMobile 
              ? "!top-auto !bottom-0 left-1/2 translate-x-[-50%] !translate-y-0 w-[100vw] max-w-none border shadow-xl rounded-t-2xl !rounded-b-none overflow-hidden flex flex-col h-[90vh] pt-0 px-0 pb-0 bg-[#f8f8fb]"
              : `${dialogWidth} bg-[#f8f8fb] !fixed !top-1/2 !left-1/2 !transform !-translate-x-1/2 !-translate-y-1/2`,
            compact && "max-h-[80vh]"
          )}>
            {isMobile ? (
              <>
                <DialogHeader className="px-4 pt-6 pb-3 flex justify-between items-center sticky top-0 bg-[#f8f8fb] z-30 border-b">
                  <DialogTitle className="text-lg font-semibold">Select Period</DialogTitle>
                  <DialogClose asChild>
                    <Button 
                      variant="ghost" 
                      size="icon"
                      className="h-8 w-8 rounded-full absolute right-4 top-5 p-0" 
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </DialogClose>
                </DialogHeader>
                <div className="px-4 flex-1 overflow-y-auto pt-4 pb-24">
                  {mobileContent}
                </div>
              </>            ) : (
              // Desktop Dialog Content - Simple header without cancel button
              <div className="p-4">
                <div className="mb-4">
                  <h2 className="text-lg font-semibold">Select Period</h2>
                </div>
                {desktopDialogContent}
              </div>)}
          </DialogContent>
        </Dialog>
      ) : (
        // Desktop - Popover (default behavior)
        <Popover open={isPopoverOpen} onOpenChange={(open) => {
          setIsPopoverOpen(open);
          if (open) {
            // Reset temp date range to current date range when opening
            setTempDateRange(dateRange);
          }
        }}>
          <PopoverTrigger asChild>{desktopTriggerButton}</PopoverTrigger>          <PopoverContent 
            className={cn(`${popoverWidth} p-6 shadow-lg border border-muted/30 rounded-lg bg-[#f8f8fb]`, compact && "p-4")} 
            align={align} 
            side="bottom" 
            sideOffset={5}
          >
            <div className="mb-4 pb-2 border-b">
              <h2 className="text-lg font-semibold">Select Period</h2>
            </div>
            {desktopContent}
          </PopoverContent>
        </Popover>
      )}
    </div>
  );
}
